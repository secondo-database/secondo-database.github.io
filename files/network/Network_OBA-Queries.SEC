################################################################################
## File: Network Queries for Object Based Approach #############################
################################################################################
##  This file is part of SECONDO.                                             ##
##                                                                            ##
##  Copyright (C) 2010, University in Hagen, Faculty of Mathematics and       ##
##  Computer Science, Database Systems for New Applications.                  ##
##                                                                            ##
##  SECONDO is free software; you can redistribute it and/or modify           ##
##  it under the terms of the GNU General Public License as published by      ##
##  the Free Software Foundation; either version 2 of the License, or         ##
##  (at your option) any later version.                                       ##
##                                                                            ##
##  SECONDO is distributed in the hope that it will be useful,                ##
##  but WITHOUT ANY WARRANTY; without even the implied warranty of            ##
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             ##
##  GNU General Public License for more details.                              ##
##                                                                            ##
##  You should have received a copy of the GNU General Public License         ##
##  along with SECONDO; if not, write to the Free Software                    ##
##  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA ##
################################################################################


# Network queries for the object based approach of the BerlinMOD Benchmark.    
#                                                                              
# The script assumes that there is a database berlinmod with a network data    
# model representation of the BerlinMOD Benchmark data.                        
#                                                                              
# This database can be generated by the script 'BerlinMOD_DataGenerator.SEC'.  
# The network data model representation and accroding indexes can be generated 
# with the script 'Network_CreateObjects.SEC'                                  
#
# Start Script Opening the Database

open database berlinmod;

# Query 1: What are the models of the vehicles with license plate numbers from 
#          QueryLicence?                                                       

let OBANres001 =
  QueryLicences feed {l}
    loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]]
    project [Licence, Model]
consume;


# Query 2: How many vehicles exist that are passenger cars?                    

let OBANres002 =
  dataSNcar feed
    filter [.Type = "passenger"]
count;


# Query 3: Where have the vehicles with licenses from QueryLicence1 been at    
#          each instant from QueryInstant1?

let OBANres003 =
  QueryLicences1 feed {l}
    loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]]
    project [Licence, Trip]
  QueryInstant1 feed {i}
  product
    projectextend[Licence, Instant_i; Pos: val(.Trip atinstant .Instant_i)]
 consume;


# Query 4: Which license plate numbers belong to vehicles that have passed the 
#          points from QueryPoints?

let OBANres004 =
  QueryPointsNet feed
    projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
    loopjoin[dataSNcar_TrajBoxNet windowintersectsS[.Prect]
             sort rdup dataSNcar gettuples]
    filter [.Trip passes .Pos]
    project [Id, Licence]
    sortby [Id asc, Licence asc]
    krdup [Id, Licence]
consume;

# Query 5: What is the minimum distance between places, where a vehicle with a 
#          license from QueryLicences1 and a vehicle with licenses from        
#          QueryLicence2 have been?

let OBANres005tmp1 =
  QueryLicences1 feed {l1}
    loopsel[dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l1]
            projectextend[Licence; TrajLine: gline2line(trajectory(.Trip))]]
consume;

let OBANres005tmp2 =
  QueryLicences2 feed {l2}
    loopsel[dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l2]
            projectextend[Licence; TrajLine: gline2line(trajectory(.Trip))]]
consume;

let OBANres005 =
  OBANres005tmp1 feed {c1}
  OBANres005tmp2 feed {c2}
  product
    projectextend [Licence_c1,
                   Licence_c2; Distance: round(distance(.TrajLine_c1,
                                                        .TrajLine_c2),3)]
    sortby[Licence_c1, Licence_c2]
consume;

# delete temporary objects

delete OBANres005tmp1;
delete OBANres005tmp2;

# Query 6: What are the pairs of license plate numbers of "trucks", that have  
#          been as close as 10m or less to each other?

let OBANres006tmp1 =
  dataSNcar feed
    filter [.Type = "truck"]
    projectextend [Licence; Ptrip: mgpoint2mpoint(.Trip), BBox: mgpbbox(.Trip)]
    projectextend [Licence, Ptrip; Box: rectangle3(minD(.BBox,1) - 5.0,
                                                   maxD(.BBox,1) + 5.0,
                                                   minD(.BBox,2) - 5.0,
                                                   maxD(.BBox,2) + 5.0,
                                                   minD(.BBox,3),
                                                   maxD(.BBox,3))]
 consume;

let OBANres006 =
  OBANres006tmp1 feed {a}
  OBANres006tmp1 feed {b}
  symmjoin [(.Box_a intersects ..Box_b) and
            (.Licence_a < ..Licence_b) and
            (everNearerThan(.Ptrip_a, ..Ptrip_b, 10.0))]
    project [Licence_a, Licence_b]
    sortby [Licence_a asc, Licence_b asc]
    krdup [Licence_a, Licence_b]
consume;

# delete temporary object

delete OBANres006tmp1;

# Query 7: What are the license plate numbers of the "passenger" cars that     
#          have reached points from QueryPoints first of all "passenger" cars  
#          during the complete observation period?

let OBANres007tmp1 =
  QueryPointsNet feed
    projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]
    loopsel[fun(t:TUPLE) dataSNcar_TrajBoxNet windowintersectsS[attr(t,Prect)]
            sort rdup dataSNcar gettuples
            filter [.Type = "passenger"]
            projectextend[Licence; Id: attr(t,Id) ,
                                   Instant: inst(initial(.Trip at attr(t,Pos)))]]
      filter[not(isempty(.Instant))]
      sortby[Id asc, Instant asc]
consume;

let OBANres007 =
  OBANres007tmp1 feed
    groupby[Id; FirstTime: group feed min[Instant]]{b}
  OBANres007tmp1 feed {a}
  symmjoin [..Id_a = .Id_b]
    filter[.Instant_a <= .FirstTime_b]
    project[Id_a, Licence_a]
    sortby[Id_a, Licence_a]
consume;

# delete temporary object

delete OBANres007tmp1;

# Query 8: What are the overall traveled distances of the vehicles with        
#          license plate numbers from QueryLicences1 during the periods from   
#          QueryPeriods1?

let OBANres008 =
  QueryLicences1 feed {l}
    loopsel [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]]
  QueryPeriods1 feed
    filter[not(isempty(.Period))] {p}
  product
    projectextend [Licence,
                   Period_p; Distance: round(length(.Trip atperiods .Period_p),3)]
    sortby[Licence, Period_p]
consume;

# Query 9: What is the longest distance that was traveled by a vehicle during  
#          each of the periods from QueryPeriods?                              

let OBANres009 =
  dataSNcar feed {c}
  QueryPeriods feed
    filter[not(isempty(.Period))]{p}
  product
    projectextend [Id_p, Period_p,
                   Licence_c; Dist: round(length(.Trip_c atperiods .Period_p),3)]
    sortby [Id_p asc, Period_p asc, Dist desc]
    groupby [Id_p, Period_p; Distance: group feed max[Dist]]
    project[Id_p, Period_p, Distance]
    project [Period_p, Distance]
consume;


# Query 10: When and where did the vehicles with license plate numbers from    
#           QueryLicences1 meet other vehicles (distance < 3m) and what are    
#           the latter licenses?                                               

let OBANres010 =
  dataSNcar feed
    projectextend[Licence; TripA: mgpoint2mpoint(.Trip), BBox: mgpbbox(.Trip)]
    projectextend[Licence, TripA;Box: rectangle2((minD(.BBox,1) - 1.5),
                                                 (maxD(.BBox,1) + 1.5),
                                                 (minD(.BBox,2) - 1.5),
                                                 (maxD(.BBox,2) + 1.5))]{c1}
  QueryLicences1 feed
    loopsel[dataSNcar_Licence_btree dataSNcar exactmatch[.Licence]]
    projectextend[Licence, Trip;  BBox: mgpbbox(.Trip)]
    projectextend [Licence, Trip; TripA: mgpoint2mpoint(.Trip),
                                  Box: rectangle2((minD(.BBox,1) - 1.5),
                                                  (maxD(.BBox,1) + 1.5),
                                                  (minD(.BBox,2) - 1.5),
                                                  (maxD(.BBox,2) + 1.5))] {c2}
  symmjoin[.Box_c1 intersects ..Box_c2]
    filter [.Licence_c1 # .Licence_c2]
    filter [everNearerThan(.TripA_c1, .TripA_c2, 3.0)]
    projectextend [Licence_c1,
      Licence_c2; Pos: .Trip_c2 atperiods deftime((distance(.TripA_c1, .TripA_c2)
                                                   < 3.0) at TRUE)]
    filter [not(isempty(.Pos))]
    project [Licence_c2, Licence_c1, Pos]
    sortby [Licence_c2 asc, Licence_c1 asc]
consume;

# Query 11: Which vehicles passed a point from QueryPoints1 at one of the      
#           instants from QueryInstant1?

let OBANres011 =
  QueryInstant1 feed {i}
  QueryPoints1Net feed
    projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]{p}
  product
    projectextend[Id_p, Pos_p, Instant_i; Box: box3d(.Prect_p, .Instant_i)]
    loopsel[fun(t:TUPLE) dataSNcar_BoxNet_timespace windowintersectsS[attr(t,Box)]
            sort rdup dataSNcar gettuples
            filter [.Trip passes (attr(t,Pos_p))]
            projectextend [Licence; Id: attr(t,Id_p), Instant: attr(t,Instant_i)]]
    sortby[Id, Licence,  Instant]
consume;

# Query 12: Which vehicles met at a point from QueryPoints1 at an instant from 
#           QueryInstant1?

let OBANres012tmp1 =
  QueryInstant1 feed {i}
  QueryPoints1Net feed
    projectextend[Id, Pos; Prect: gpoint2rect(.Pos)]{p}
  product
    loopsel[fun(t:TUPLE)
            dataSNcar_BoxNet_timespace windowintersectsS[box3d(attr(t,Prect_p),
                                                               attr(t,Instant_i))]
            sort rdup dataSNcar gettuples
            filter [.Trip passes (attr(t,Pos_p))]
            projectextend [Licence; Id_p: attr(t,Id_p),
                                    Pos_p: attr(t,Pos_p),
                                    Instant_i: attr(t,Instant_i)]]
    sortby [Id_p asc, Instant_i asc, Licence asc]
consume;

let OBANres012 =
  OBANres012tmp1 feed {c1}
  OBANres012tmp1 feed {c2}
  symmjoin [(.Licence_c1 < ..Licence_c2) and
            (.Id_p_c1 = ..Id_p_c2) and
            (.Instant_i_c1 = ..Instant_i_c2)]
    project [Id_p_c1, Pos_p_c1, Instant_i_c1, Licence_c1, Licence_c2]
    sortby [Id_p_c1 asc, Instant_i_c1 asc, Licence_c2 asc]
consume;

# delete temporary objects

delete OBANres012tmp1;

# Query 13: Which vehicles traveled within one of the regions from             
#           QueryRegions1 during the periods from QueryPeriods1?

let OBANres013 =
  dataSNcar feed {c}
  QueryRegions1Net feed
    filter[not(isempty(.Region))] {r}
  symmjoin[.Trip_c passes ..Region_r]
    projectextend[Licence_c, Id_r, Region_r; Trip: .Trip_c at .Region_r]
  QueryPeriods1 feed filter[not(isempty(.Period))]{p}
  symmjoin [.Trip present ..Period_p]
    projectextend[Id_r, Period_p; Licence: .Licence_c,
                                  Trip: .Trip atperiods .Period_p]
    filter [no_components(.Trip) > 0]
    project[Id_r, Period_p, Licence]
    sortby[Id_r asc, Period_p asc, Licence asc]
consume;

# Query 14: Which vehicles traveled within one of the regions from             
#           QueryRegions1 at one of the instants from QueryInstant1?           

let OBANres014 =
  dataSNcar feed
  QueryInstant1 feed
  product
    projectextend[Licence, Instant; PosX: val(.Trip atinstant .Instant)]
    projectextendstream[Licence, Instant; Pos: polygpoints(.PosX,B_NETWORK)]
  QueryRegions1Net feed filter[not(isempty(.Region))]
  symmjoin[.Pos inside ..Region]
    project[Id, Instant, Licence]
    sortby [Id asc, Instant asc, Licence asc]
    krdup[Id, Instant, Licence]
consume;

#  Query 15: Which vehicles passed a point from QueryPoints1 during a period   
#            from QueryPeriods1?

let OBANres015 =
  QueryPoints1Net feed
    projectextend[Id, Pos; Prect: gpoint2rect(.Pos)] {p}
  QueryPeriods1 feed
    filter[not(isempty(.Period))] {t}
  product
    projectextend[Id_p, Pos_p, Period_t; Box: box3d(.Prect_p, .Period_t)]
    loopsel[fun(t:TUPLE)
            dataSNcar_BoxNet_timespace windowintersectsS[attr(t, Box)]
            sort rdup dataSNcar gettuples
            filter[(.Trip atperiods (attr(t,Period_t))) passes (attr(t,Pos_p))]
            projectextend[; Id: attr(t,Id_p),
                            Period: attr(t,Period_t),
                            Licence: .Licence]]
    sortby [Id asc, Period asc, Licence asc]
    krdup [Id, Period, Licence]
consume;

# Query 16: List the pairs of licenses for vehicles the first from             
#           QueryLicences1, the second from QueryLicences2, where the          
#           corresponding vehicles are both present within a region from       
#           QueryRegions1 during a period from QueryPeriod1, but do not meet   
#           each other there and then.

let OBANres016 =
  QueryLicences1 feed {l}
      loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]] {c}
    QueryPeriods1 feed
      filter[not(isempty(.Period))]{p}
    symmjoin [.Trip_c present ..Period_p]
      projectextend[Id_p, Period_p; Licence: .Licence_c,
                                    Trip: .Trip_c atperiods .Period_p]
      filter [no_components(.Trip) > 0]
    QueryRegions1Net feed
      filter[not(isempty(.Region))] {r}
    symmjoin[.Trip passes ..Region_r]
      projectextend[Licence, Id_r, Region_r, Id_p,
        Period_p; Trip: .Trip at .Region_r]
      filter [no_components(.Trip) > 0]{a}
  QueryLicences2 feed {l}
      loopjoin [dataSNcar_Licence_btree dataSNcar exactmatch [.Licence_l]] {c}
    QueryPeriods1 feed
      filter[not(isempty(.Period))]{p}
    symmjoin [.Trip_c present ..Period_p]
      projectextend[Id_p, Period_p; Licence: .Licence_c,
                                    Trip: .Trip_c atperiods .Period_p]
      filter [no_components(.Trip) > 0]
    QueryRegions1Net feed filter[not(isempty(.Region))] {r}
    symmjoin[.Trip passes ..Region_r]
      projectextend[Licence, Id_r, Region_r, Id_p,
        Period_p; Trip: .Trip at .Region_r]
      filter [no_components(.Trip) > 0]{b}
  symmjoin[(.Id_r_a = ..Id_r_b) and (.Id_p_a = ..Id_p_b)]
    filter [.Licence_a # .Licence_b]
    filter[not(.Trip_a intersects .Trip_b)]
    project [Id_r_a, Period_p_a, Licence_a, Licence_b]
    sortby[Id_r_a, Period_p_a, Licence_a, Licence_b]
consume;

# Query 17: Which points from QueryPoints have been visited by a maximum       
#           number of different vehicles?

let OBANres017tmp1 =
  dataSNcar feed {c}
  QueryPointsNet feed {p}
  symmjoin [.Trip_c passes ..Pos_p]
    project [Id_p, Licence_c]
    sortby [Id_p, Licence_c]
    krdup [Id_p, Licence_c]
    groupby[Id_p; Hits: group feed count]
consume;

let OBANres017 =
  OBANres017tmp1 feed
    filter [.Hits = (OBANres017tmp1 feed max[Hits])]
    project [Id_p, Hits]
consume;

#delete temporary object

delete OBANres017tmp1;

# Save runtime information

let QRT_NET_OBA = SEC2COMMANDS feed consume;

# To save runtime information on hard disk uncomment next line
# save QRT_NET_OBA to 'NetworkOBARunTimes.DAT';

# Finish Script and Close Database

close database;
