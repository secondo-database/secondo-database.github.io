# The script imports Openstreetmap data from osm-File and creates a network
# object from this data source
#
# Create and open database

create database keDB;

open database keDB;

# Define source Thfile for import and network creation

let SOURCEFILE = 'KL_Enkenbach.osm';

# import osm data from file

query fullosmimport(SOURCEFILE, "Osm");

# The tag layer must not be set in osm data if the way is on layer 0.
# Because we decide based on the layer tag if two ways intersect we extend
# the missing layer tag for all ways where no layer is given with value 0.

let WayIdsWithoutTags =
  OsmWays feed
    project [WayId]
    sortby[WayId]
  OsmWayTags feed
    projectextend[;WayId: .WayIdInTag]
    sortby [WayId]
    rdup
  mergediff
consume;

let OsmWayTagsLayerExtended =
  OsmWayTags feed
    sortby [WayIdInTag]
    groupby [WayIdInTag; C: group feed
                                  filter [.WayTagKey = "layer"]
                                  count]
    filter [.C = 0]
    projectextend [WayIdInTag; WayTagKey: 'layer',
                               WayTagValue: '0']
consume;

let LayerTagForWayIdsWithoutTag =
  WayIdsWithoutTags feed
    projectextend[; WayIdInTag: .WayId,
                    WayTagKey: 'layer',
                    WayTagValue: '0']
consume;

let OsmWayTagNew =
  ( ( OsmWayTags feed)
    ( OsmWayTagsLayerExtended feed)
    concat)
  ( LayerTagForWayIdsWithoutTag feed)
    concat
consume;

# Connect Spatial Information for nodes and ways
# We distinguish between different forms of way curves, because the network
# knows only curves of type sline which may only have one start and end point,
# and may not cross themself. Therefore not curve values values which do not
# fit in this system have to be splitted into disjoint sline values.

let SpatialPosOfNodes =
   OsmNodes feed
     projectextend [NodeId; NodePos: makepoint(.Lon,.Lat)]
consume;

let SpatialWayCurveSimple =
  OsmWays feed
  SpatialPosOfNodes feed
  hashjoin[NodeRef, NodeId, 99997]
    project[WayId, NodeCounter, NodePos]
    sortby [WayId, NodeCounter]
    groupby[WayId; WayCurve: group feed
                                   projecttransformstream[NodePos]
                                   collect_sline[TRUE]]
consume;

let SpatialWayCurveComplex =
  OsmWays feed
  SpatialWayCurveSimple feed 
    filter[not(isdefined(.WayCurve))] {s}
  hashjoin[WayId, WayId_s]
    project[WayId, NodeCounter, NodeRef]
  SpatialPosOfNodes feed
  hashjoin[NodeRef, NodeId, 99997]
    project[WayId, NodeCounter, NodePos]
    sortby [WayId, NodeCounter]
    groupby[WayId; WayCurve: group feed
                                   projecttransformstream[NodePos]
                                   collect_line[TRUE],
                   StartPointCurve: group feed head[1] extract[NodePos]]
    projectextendstream[WayId, StartPointCurve; WayC: .WayCurve longlines]
    addcounter[PartNo,1]
    projectextend[WayId, PartNo, StartPointCurve,
                  WayC; StartPoint: getstartpoint(.WayC),
                        EndPoint: getendpoint(.WayC)]
    sortby[WayId, PartNo]
    extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
    sortby[WayId, PartNo]
    projectextend[WayId; WayCurve: ifthenelse(.StartPointCurve = .StartPoint,
                                              .WayC,
                                     ifthenelse(.StartPoint = .PrevEndPoint,
                                                .WayC,
                                                set_startsmaller(.WayC,
                                                                 not(get_startsmaller(.WayC)))))]
consume;

let SpatialWayCurve =
  ( SpatialWayCurveSimple feed filter [isdefined(.WayCurve)])
  ( SpatialWayCurveComplex feed)
  concat
    filter [isdefined(.WayCurve)]
consume;

# Collect tag information by identfier

let NestedNodeRel =
  SpatialPosOfNodes feed
  OsmNodeTags feed
  hashjoin[NodeId,NodeIdInTag]
    project[NodeId, NodePos, NodeTagKey, NodeTagValue]
    sortby[NodeId, NodePos, NodeTagKey, NodeTagValue]
    rdup
    nest [NodeId, NodePos; NodeInfo]
consume;

let NestedWayRel =
  SpatialWayCurve feed
  OsmWayTagNew feed
  hashjoin [WayId, WayIdInTag]
    project[WayId, WayCurve, WayTagKey, WayTagValue]
    filter[not(((.WayTagKey = "oneway") and
           ((.WayTagValue = "no") or
            (.WayTagValue = "false") or
            (.WayTagValue = "0"))))]
    sortby[WayId, WayCurve, WayTagKey, WayTagValue]
    rdup
    nest[WayId, WayCurve; WayInfo]
    projectextend[WayId, WayInfo; WayC: .WayCurve,
                  ChangeDirection: ifthenelse(.WayInfo afeed
                                                      filter [.WayTagKey = "oneway"]
                                                      filter [(.WayTagValue = "-1") or
                                                              (.WayTagValue = "reverse")]
                                              count > 0,
                                              TRUE, FALSE)]
    projectextend[WayId, WayInfo; WayCurve: ifthenelse(.ChangeDirection,
                                                       set_startsmaller(.WayC,
                                                              not(get_startsmaller(.WayC))),
                                                       .WayC)]
consume;

let NestedRelationRel =
  OsmRelations feed
  OsmRelationTags feed
  hashjoin[RelId, RelIdInTag]
    project[RelId, RefCounter, MemberRef, MemberType, MemberRole, RelTagKey, RelTagValue]
    sortby[RelId, RefCounter,  MemberRef, MemberType, MemberRole, RelTagKey, RelTagValue]
    rdup
    nest [RelId, RefCounter, MemberRef, MemberType, MemberRole; RefInfo]
    nest [RelId; RelInfo]
consume;

# Build roads defined by way relation of osm
# select highway data

let RoadParts = 
  NestedWayRel feed
    filter [.WayInfo afeed
                     filter[.WayTagKey = "highway"]
                     filter[(.WayTagValue contains "living") or
                            (.WayTagValue contains "motorway") or
                            (.WayTagValue contains "path") or
                            (.WayTagValue contains "primary") or
                            (.WayTagValue contains "residential") or
                            (.WayTagValue contains "road") or
                            (.WayTagValue contains "secondary") or
                            (.WayTagValue contains "service") or
                            (.WayTagValue contains "tertiary") or
                            (.WayTagValue contains "trunk") or
                            (.WayTagValue contains "track") or
                            (.WayTagValue contains "unclassified") or
                            (.WayTagValue contains "pedestrian")]
            count > 0]
    filter [isdefined(.WayCurve)]
    filter [not(isempty(.WayCurve))]
consume;

# Roads may consists of more than one osm way. The osm ways of very long roads
# are connectedof by a ref tag which is equal for all ways belonging to the same
# road.
# The roads created by this may not consist of sline values only such that we
# have to distinguish between simple and complex road curves when we generate
# the resulting road curves.

let RoadsByRefH1 =
  RoadParts feed
    filter[not(iscycle(.WayCurve))]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "oneway"]
            count = 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "ref"]
           count > 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "highway"]
                    filter[not(.WayTagValue contains "link")]
           count > 0]
    unnest[WayInfo]
      filter[.WayTagKey = "ref"]
      projectextendstream[WayId, WayCurve; RefToken: tokenize(' '+.WayTagValue,";/")]
      projectextend[WayId, WayCurve; Ref: trim(toObject('"'+.RefToken +'"',"a"))]
      sortby[Ref, WayCurve]
consume;

let RoadsByRefSimpleH1 =
  RoadsByRefH1 feed
    sortby[Ref, WayCurve]
    groupby[Ref; C: group feed count]
consume;

let RoadsByRefSimpleH2 =
  RoadsByRefSimpleH1 feed
    filter [.C = 1] {r1}
  RoadsByRefH1 feed {r2}
  hashjoin[Ref_r1, Ref_r2]
    projectextend[; Ref: .Ref_r1,
                    RoadCurve: .WayCurve_r2]
consume;

let RoadsByRefSimpleH3 = 
  RoadsByRefSimpleH1 feed
    filter [.C > 1] {r1}
  RoadsByRefH1 feed {r2}
  hashjoin[Ref_r1, Ref_r2]
    projectextend[; Ref: .Ref_r2,
                    WayCurve: .WayCurve_r2]
    sortby[Ref, WayCurve]
    groupby[Ref; RoadC: group feed projecttransformstream[WayCurve]
                                   collect_sline[TRUE]]
    projectextend[Ref; RoadCurve: .RoadC]
consume;

let RoadsByRefSimple =
  ( RoadsByRefSimpleH2 feed)
  ( RoadsByRefSimpleH3 feed)
  concat
    sortby[Ref, RoadCurve]
consume;

let RoadsByRefComplex =
  RoadsByRefH1 feed
    sortby[Ref, WayCurve]
  RoadsByRefSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[Ref, Ref_s]
    projectextend[Ref, WayCurve; StartPoint: getstartpoint(.WayCurve)]
    sortby[Ref, WayCurve, StartPoint]
    groupby[Ref; RoadC: group feed projecttransformstream[WayCurve]
                                   collect_line[TRUE],
                 StartPointCurve: group feed head[1] extract[StartPoint]]
    projectextendstream[Ref, StartPointCurve; RoadCur: .RoadC longlines]
    addcounter[PartNo,1]
    projectextend[Ref, PartNo, StartPointCurve,
                  RoadCur; StartPoint: getstartpoint(.RoadCur),
                           EndPoint: getendpoint(.RoadCur)]
    sortby[Ref, PartNo]
    extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
    sortby[Ref, PartNo]
    projectextend[Ref; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint,
                                             .RoadCur,
                                             ifthenelse(.StartPoint = .PrevEndPoint,
                                                        .RoadCur,
                                                        set_startsmaller(.RoadCur,
                                                                         not(get_startsmaller(.RoadCur)))))]
consume;

let RoadsByRef =
  ( RoadsByRefSimple feed
      filter [isdefined(.RoadCurve)])
  ( RoadsByRefComplex feed)
  concat
    filter [isdefined(.RoadCurve)]
consume;

# Another form of connecting way segments to long roads is the name tag which
# is equal for all ways belonging to the same road. 
# Again we have to distinguish between simple and complex road curves generating
# the resulting road curves.

let RoadsByNameH1 =
  RoadParts feed
    filter[not(iscycle(.WayCurve))]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "oneway"]
            count = 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "name"]
            count > 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "ref"]
           count = 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "highway"]
                    filter[not(.WayTagValue contains "link")]
           count > 0]
    unnest[WayInfo]
      filter[.WayTagKey = "name"]
      projectextend[WayId, WayCurve; Name: trim(toObject('"'+.WayTagValue +'"',"a"))]
      sortby[Name, WayCurve]
consume;

let RoadsByNameSimpleH1 =
  RoadsByNameH1 feed
    sortby[Name, WayCurve]
    groupby[Name; C: group feed count]
consume;

let RoadsByNameSimpleH2 =
  RoadsByNameSimpleH1 feed
    filter [.C = 1] {r1}
  RoadsByNameH1 feed {r2}
  hashjoin[Name_r1, Name_r2]
    projectextend[;Name: .Name_r1, RoadCurve: .WayCurve_r2]
consume;

let RoadsByNameSimpleH3 =
  RoadsByNameSimpleH1 feed
    filter [.C > 1] {r1}
  RoadsByNameH1 feed {r2}
  hashjoin[Name_r1, Name_r2]
    projectextend[; Name: .Name_r1, WayCurve: .WayCurve_r2]
    sortby[Name, WayCurve]
    groupby[Name; RoadC: group feed projecttransformstream[WayCurve]
                                    collect_sline[TRUE]]
    projectextend[Name; RoadCurve: .RoadC]
consume;

let RoadsByNameSimple =
  ( RoadsByNameSimpleH2 feed)
  ( RoadsByNameSimpleH3 feed)
  concat
    sortby[Name, RoadCurve]
consume;

let RoadsByNameComplex =
  RoadsByNameH1 feed
  RoadsByNameSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[Name, Name_s]
    projectextend[Name, WayCurve; StartPoint: getstartpoint(.WayCurve)]
    sortby[Name, WayCurve, StartPoint]
    groupby[Name; RoadC: group feed projecttransformstream[WayCurve]
                                    collect_line[TRUE],
                  StartPointCurve: group feed head[1] extract[StartPoint]]
    projectextendstream[Name, StartPointCurve; RoadCur: .RoadC longlines]
    addcounter[PartNo,1]
    projectextend[Name, PartNo, StartPointCurve,
                  RoadCur; StartPoint: getstartpoint(.RoadCur),
                           EndPoint: getendpoint(.RoadCur)]
    sortby[Name, PartNo]
    extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
    sortby[Name, PartNo]
    projectextend[Name; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint,
                                     .RoadCur,
                                     ifthenelse(.StartPoint = .PrevEndPoint,
                                                .RoadCur,
                                                set_startsmaller(.RoadCur,
                                                                 not(get_startsmaller(.RoadCur)))))]
consume;

let RoadsByName =
  ( RoadsByNameSimple feed filter [isdefined(.RoadCurve)])
  ( RoadsByNameComplex feed)
  concat
    filter [isdefined(.RoadCurve)]
consume;

# road links connect bigger roads for example two highways are connected by
# several links.

let RoadLinksH1 =
  RoadParts feed
    filter[not(iscycle(.WayCurve))]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "oneway"]
            count = 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "highway"]
                    filter[.WayTagValue contains "link"]
           count > 0]
  unnest[WayInfo]
    filter[.WayTagKey = "highway"]
    filter[.WayTagValue contains "link"]
    project[WayId, WayCurve]
    sortby[WayId, WayCurve]
consume;

let RoadLinksSimpleH1 =
  RoadLinksH1 feed
    sortby[WayId, WayCurve]
    groupby[WayId; C: group feed count]
consume;

let RoadLinksSimpleH2  =
  RoadLinksSimpleH1 feed
    filter [.C = 1] {r1}
  RoadLinksH1 feed {r2}
  hashjoin [WayId_r1, WayId_r2]
    projectextend[; WayId: .WayId_r1, RoadCurve: .WayCurve_r2]
consume;

let RoadLinksSimpleH3 =
  RoadLinksSimpleH1 feed
    filter [.C > 1] {r1}
  RoadLinksH1 feed {r2}
  hashjoin [WayId_r1, WayId_r2]
    projectextend[;  WayId: .WayId_r1, WayCurve: .WayCurve_r2]
    sortby[WayId, WayCurve]
    groupby[WayId; RoadC: group feed projecttransformstream[WayCurve]
                                     collect_sline[TRUE]]
    projectextend[WayId; RoadCurve: .RoadC]
consume;

let RoadLinksSimple =
  ( RoadLinksSimpleH2 feed)
  ( RoadLinksSimpleH3 feed)
  concat
    sortby[WayId, RoadCurve]
consume;

let RoadLinksComplex =
  RoadLinksH1 feed
  RoadLinksSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[WayId, WayId_s]
    projectextend[WayId, WayCurve; StartPoint: getstartpoint(.WayCurve)]
    sortby[WayId, WayCurve, StartPoint]
    groupby[WayId; RoadC: group feed projecttransformstream[WayCurve]
                                    collect_line[TRUE],
                   StartPointCurve: group feed head[1] extract[StartPoint]]
    projectextendstream[WayId, StartPointCurve; RoadCur: .RoadC longlines]
    addcounter[PartNo,1]
    projectextend[WayId, PartNo, StartPointCurve,
                  RoadCur; StartPoint: getstartpoint(.RoadCur),
                           EndPoint: getendpoint(.RoadCur)]
    sortby[WayId, PartNo]
    extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
    sortby[WayId, PartNo]
    projectextend[WayId; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint,
                                      .RoadCur,
                                      ifthenelse(.StartPoint = .PrevEndPoint,
                                         .RoadCur,
                                         set_startsmaller(.RoadCur,
                                                          not(get_startsmaller(.RoadCur)))))]
consume;

let RoadLinks =
  ( RoadLinksSimple feed
      filter [isdefined(.RoadCurve)])
  ( RoadLinksComplex feed)
  concat
    filter [isdefined(.RoadCurve)]
consume;

# all ways not selected before build also valid roads if they are not marked
# to be oneways or roundabouts.

let RoadRestH1 =
  RoadParts feed
    filter[not(iscycle(.WayCurve))]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "oneway"]
           count = 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey contains "ref"]
           count = 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey contains "name"]
           count = 0]
    filter[.WayInfo afeed
                    filter[.WayTagKey = "highway"]
                    filter[.WayTagValue contains "link"]
           count = 0]
    unnest[WayInfo]
      filter[.WayTagKey = "highway"]
      project[WayId, WayCurve]
      sortby[WayId, WayCurve]
consume;

let RoadRestSimpleH1 =
  RoadRestH1 feed
    sortby[WayId, WayCurve]
    groupby[WayId; C: group feed count]
consume;

let RoadRestSimpleH2 =
  RoadRestSimpleH1 feed
    filter [.C = 1] {r1}
  RoadRestH1 feed {r2}
  hashjoin[WayId_r1, WayId_r2]
    projectextend[; WayId: .WayId_r1, RoadCurve: .WayCurve_r2]
consume;

let RoadRestSimpleH3 =
  RoadRestSimpleH1 feed
    filter [.C > 1] {r1}
  RoadRestH1 feed {r2}
  hashjoin[WayId_r1, WayId_r2]
    projectextend[; WayId: .WayId_r1, WayCurve: .WayCurve_r2]
    sortby[WayId, WayCurve]
    groupby[WayId; RoadC: group feed projecttransformstream[WayCurve]
                                     collect_sline[TRUE]]
    projectextend[WayId; RoadCurve: .RoadC]
consume;

let RoadRestSimple =
  ( RoadRestSimpleH2 feed)
  ( RoadRestSimpleH3 feed)
  concat
    sortby[WayId, RoadCurve]
consume;

let RoadRestComplex =
  RoadRestH1 feed
  RoadRestSimple feed
    filter[not(isdefined(.RoadCurve))] {s}
  hashjoin[WayId, WayId_s]
    projectextend[WayId, WayCurve; StartPoint: getstartpoint(.WayCurve)]
    sortby[WayId, WayCurve, StartPoint]
    groupby[WayId; RoadC: group feed projecttransformstream[WayCurve]
                                     collect_line[TRUE],
                   StartPointCurve: group feed head[1] extract[StartPoint]]
    projectextendstream[WayId, StartPointCurve; RoadCur: .RoadC longlines]
    addcounter[PartNo,1]
    projectextend[WayId, PartNo, StartPointCurve,
                  RoadCur; StartPoint: getstartpoint(.RoadCur),
                           EndPoint: getendpoint(.RoadCur)]
    sortby[WayId, PartNo]
    extend_last[PrevEndPoint: ..EndPoint :: [const point value(0.0 0.0)]]
    sortby[WayId, PartNo]
    projectextend[WayId; RoadCurve: ifthenelse(.StartPointCurve = .StartPoint,
                                      .RoadCur,
                                      ifthenelse(.StartPoint = .PrevEndPoint,
                                                 .RoadCur,
                                                 set_startsmaller(.RoadCur,
                                                                  not(get_startsmaller(.RoadCur)))))]
consume;

let RoadRest =
  ( RoadRestSimple feed
      filter [isdefined(.RoadCurve)])
  ( RoadRestComplex feed)
  concat
    filter [isdefined(.RoadCurve)]
consume;

# one way streets

let RoadsByOneway =
  RoadParts feed
    filter [not(iscycle(.WayCurve))]
    filter [.WayInfo afeed
                     filter [.WayTagKey = "oneway"]
            count > 0]
    projectextend[; Name: num2string(.WayId), Curve: .WayCurve]
consume;

# road cycles
  
let RoadsByCycle =
  RoadParts feed
    filter[iscycle(.WayCurve)]
    projectextend[;Name: num2string(.WayId), Curve: set_startsmaller(.WayCurve, TRUE)]
consume;

# concat all forms of roads to roads relation

let Roads =
  ( ( ( RoadsByRef feed
          projectextend[;Name: .Ref, Curve: .RoadCurve])
      ( RoadsByName feed
          projectextend[;Name: .Name, Curve: .RoadCurve])
      concat)
    ( ( RoadLinks feed
          projectextend[;Name: num2string(.WayId), Curve: .RoadCurve])
      ( RoadRest feed
          projectextend[;Name: num2string(.WayId), Curve: .RoadCurve])
      concat)
    concat)
  ( (RoadsByCycle feed)
    (RoadsByOneway feed)
    concat)
  concat
    filter [isdefined(.Curve)]
    extend[CurvLength: size(.Curve)]
    sortby [CurvLength desc]
    addcounter[Rid,1]
consume;

# Build Junctions
# Junction are defined to be crossings between way curves or death ends of a
# road

let ExtendedRoadParts =
  RoadParts feed
    projectextend[WayId; StartPoint: getstartpoint(.WayCurve),
                         EndPoint: getendpoint(.WayCurve)]
consume;

let CrossingPtsTmpH1 =
   RoadParts feed
     unnest[WayInfo]
       filter[.WayTagKey = "layer"]
       projectextend[WayId, WayCurve; Layer: .WayTagValue]
consume;

let CrossingPtsTmp =
   CrossingPtsTmpH1 feed {s1}
   CrossingPtsTmpH1 feed {s2}
   itSpatialJoin [WayCurve_s1, WayCurve_s2, 4 ,8]
     filter[(.Layer_s1 = .Layer_s2)]
     filter[.WayId_s1 < .WayId_s2]
     filter[.WayCurve_s1 intersects .WayCurve_s2]
     projectextendstream[WayId_s1,
                         WayId_s2; Pt: components(crossings(.WayCurve_s1,
                                                            .WayCurve_s2))]
     filter[isdefined(.Pt)]
     projectextend[Pt; WayId1: .WayId_s1, WayId2: .WayId_s2]
consume;

let CrossingsAndRoadPartEndPoints =
  ( ( ExtendedRoadParts feed
        projectextend[WayId; Point: .StartPoint])
    ( ExtendedRoadParts feed
        projectextend[WayId; Point: .EndPoint])
     concat)
  ( ( CrossingPtsTmp feed
        projectextend[; WayId: .WayId1, Point: .Pt])
    ( CrossingPtsTmp feed
        projectextend[; WayId: .WayId2, Point: .Pt])
    concat)
  concat
    sortby[WayId, Point]
    krduph[WayId, Point]
consume;

let RoadEnds =
  Roads feed
    projectextend[Rid; StartPoint: getstartpoint(.Curve),
                       EndPoint: getendpoint(.Curve)]
consume;

let RoadEndPointsA =
  ( RoadEnds feed
    projectextend[Rid; Point: .StartPoint])
  ( RoadEnds feed
    projectextend[Rid; Point: .EndPoint])
  concat
    sortby[Rid, Point]
    rdup
consume;

let AddJuncs =
  RoadEndPointsA feed
    project[Point]
    sortby[Point]
  CrossingsAndRoadPartEndPoints feed
    project[Point]
    sortby[Point]
  mergediff
consume;

let JunctionIds =
  ( CrossingsAndRoadPartEndPoints feed project[Point])
  ( AddJuncs feed)
  concat
    sortby [Point]
    rdup
    filter [isdefined(.Point)]
    addcounter[Jid,1]
consume;

# The junctions have more than one road position if they are not a death end
# of a road

let JunctionPositionsOnRoads1 =
  CrossingsAndRoadPartEndPoints feed
    filter[isdefined(.Point)]{p1}
  JunctionIds feed
    filter[isdefined(.Point)]{j}
  itSpatialJoin[Point_p1,Point_j,4,8]
    filter [.Point_p1 = .Point_j]
    projectextend[;Jid: .Jid_j, Point: .Point_j, WayId: .WayId_p1]
  RoadParts feed {w}
  hashjoin[WayId, WayId_w]
    projectextend[Jid, Point,
                  WayId; WayCurve: .WayCurve_w,
                         WayStartPoint: getstartpoint(.WayCurve_w),
                         WayEndPoint: getendpoint(.WayCurve_w)]
  Roads feed {r1}
  itSpatialJoin[Point,Curve_r1,4,8]
    filter[.Point inside .Curve_r1]
    filter[.WayStartPoint inside .Curve_r1]
    filter[.WayEndPoint inside .Curve_r1]
    filter[.WayCurve inside .Curve_r1]
    projectextend[Jid, Point,
                  WayId; Rid: .Rid_r1,
                         RMeas: atpoint(.Curve_r1,.Point),
                         WayStartPosOnRoute: atpoint(.Curve_r1, .WayStartPoint),
                         WayEndPosOnRoute: atpoint(.Curve_r1, .WayEndPoint)]
    sortby[Jid, Point, WayId, Rid, RMeas, WayStartPosOnRoute, WayEndPosOnRoute]
    rdup
consume;

let JunctionPositionsOnRoads2 =
  CrossingsAndRoadPartEndPoints feed
    filter[isdefined(.Point)]{p1}
  JunctionIds feed
    filter[isdefined(.Point)]{j}
  itSpatialJoin[Point_p1,Point_j,4,8]
    filter [.Point_p1 = .Point_j]
    projectextend[;Jid: .Jid_j, Point: .Point_j, WayId: .WayId_p1]
    sortby[Jid, Point, WayId]
  JunctionPositionsOnRoads1 feed
    project[Jid, Point, WayId]
    sortby[Jid, Point, WayId]
  mergediff
  RoadParts feed {w}
  hashjoin[WayId, WayId_w]
    projectextend[Jid, Point,
                  WayId; WayCurve: .WayCurve_w,
                         WayStartPoint: getstartpoint(.WayCurve_w),
                         WayEndPoint: getendpoint(.WayCurve_w)]
  Roads feed {r1}
  itSpatialJoin[Point,Curve_r1,4,8]
    filter[.Point inside .Curve_r1]
    projectextend[Jid, Point,
                  WayId; Rid: .Rid_r1,
                  RMeas: atpoint(.Curve_r1,.Point),
                  WayStartPosOnRoute: atpoint(.Curve_r1,
                                              getstartpoint(intersection(.WayCurve,
                                                                         .Curve_r1))),
                  WayEndPosOnRoute: atpoint(.Curve_r1,
                                            getendpoint(intersection(.WayCurve,
                                                                     .Curve_r1)))]
    sortby[Jid, Point, WayId, Rid, RMeas, WayStartPosOnRoute, WayEndPosOnRoute]
    rdup
consume;

let JunctionPositionsOnRoads =
  ( JunctionPositionsOnRoads1 feed)
  ( JunctionPositionsOnRoads2 feed)
  concat
consume;

let JunctionsAtRoadEnds =
  RoadEndPointsA feed
    filter[isdefined(.Point)] {r}
  JunctionIds feed
    filter [isdefined(.Point)] {j}
  itSpatialJoin[Point_r,Point_j,4,8]
    filter [.Point_r = .Point_j]
    projectextend[; Jid: .Jid_j, Point: .Point_j, Rid: .Rid_r]
  Roads feed {r1}
  hashjoin[Rid, Rid_r1]
    projectextend[Jid, Point, Rid; RMeas: atpoint(.Curve_r1,.Point)]
    sortby [Jid, Point, Rid, RMeas]
    rdup
consume;

let JunctionsAtRoadEndPairs =
  JunctionsAtRoadEnds feed {j1}
  JunctionsAtRoadEnds feed {j2}
  hashjoin[Jid_j1, Jid_j2]
    filter  [.Rid_j1 <= .Rid_j2]
    filter [.RMeas_j1 # .RMeas_j2]
    projectextend [;Jid: .Jid_j1,
                    R1id: .Rid_j1,
                    R1Meas: .RMeas_j1,
                    R2id: .Rid_j2,
                    R2Meas: .RMeas_j2,
                    NewCC: 65535]
    sortby [Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
    krduph[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let JunctionRoadPairs =
  JunctionPositionsOnRoads feed {j1}
  JunctionPositionsOnRoads feed {j2}
  hashjoin[Jid_j1, Jid_j2]
    filter[.Rid_j1 <= .Rid_j2]
    projectextend[; Jid: .Jid_j1,
                    Point: .Point_j1,
                    R1id: .Rid_j1,
                    R1Meas: .RMeas_j1,
                    R2id: .Rid_j2,
                    R2Meas: .RMeas_j2,
                    CC: 65535,
                    WayId1: .WayId_j1,
                    Way1StartPosOnRoute: .WayStartPosOnRoute_j1,
                    Way1EndPosOnRoute: .WayEndPosOnRoute_j1,
                    WayId2: .WayId_j2,
                    Way2StartPosOnRoute: .WayStartPosOnRoute_j2,
                    Way2EndPosOnRoute: .WayEndPosOnRoute_j2]
    sortby [Jid, R1id, R1Meas, R2id, R2Meas, CC, Way1StartPosOnRoute,
            Way1EndPosOnRoute, Way2StartPosOnRoute, Way2EndPosOnRoute,
            WayId1, WayId2]
    krduph[Jid, R1id, R1Meas, R2id, R2Meas, CC, Way1StartPosOnRoute,
           Way1EndPosOnRoute, Way2StartPosOnRoute, Way2EndPosOnRoute]
consume;

# Compute correct Connectivity Codes for all junctions
#
# Select Road End Points

let RoadEndPoints =
  JunctionRoadPairs feed
    sortby [Jid, R1id, R1Meas, R2id, R2Meas]
    groupby [Jid; C: group feed count]
     filter [.C = 1] {s}
  JunctionRoadPairs feed
  hashjoin[Jid_s, Jid]
    filter[.R1id = .R2id]
    filter[.WayId1 = .WayId2]
    projectextend[Jid, R1id, R1Meas, R2id,
                  R2Meas; NewCC: ifthenelse(.R1Meas = 0, 16, 2)]
consume;

# Select One Way Curves

let OneWayCurveIds =
  NestedWayRel feed
    filter[.WayInfo afeed
                    filter[.WayTagKey = "oneway"]
                    filter[not((.WayTagValue = "no") or
                               (.WayTagValue = "false") or
                               (.WayTagValue = "0"))]
           count > 0]
    project[WayId]
consume;

# motorways are also oneways

let MotorWayCurveIds =
  NestedWayRel feed
    filter[.WayInfo afeed
                    filter [.WayTagKey = "highway"]
                    filter [.WayTagValue = "motorway"]
            count > 0]
    project [WayId]
consume;

# roundabout are also oneways

let RoundaboutWayCurveIds =
  NestedWayRel feed
    filter [.WayInfo afeed
                     filter [.WayTagKey = "junction"]
                     filter [.WayTagValue = "roundabout"]
            count > 0]
    project [WayId]
consume;

let OneWayIds =
  ( ( OneWayCurveIds feed)
    ( RoundaboutWayCurveIds feed)
    concat)
  ( MotorWayCurveIds feed)
  concat
    sortby [WayId]
    rdup
consume;

# set connectivity code for junctions of roundabouts

let JunctionsOfCycles =
  JunctionRoadPairs feed
    filter [.R1id = .R2id]
    filter [.WayId1 = .WayId2]
  RoundaboutWayCurveIds feed
  hashjoin[WayId1, WayId]
    projectextend[Jid, R1id, R1Meas, R2id, R2Meas; NewCC: 1285]
consume;

# set connectivity codes for oneway junctions

let JunctionsOfOnewaysSameRID1 =
  JunctionRoadPairs feed
    filter[.R1id = .R2id]
    filter[.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId1, WayId]
  projectextend[Jid, R1id, R1Meas, R2id,
                R2Meas; NewCC: ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                                           ifthenelse(.R1Meas = .Way1EndPosOnRoute,
                                                      .CC binand 21845,
                                                      ifthenelse(.R1Meas = .Way1StartPosOnRoute,
                                                                 .CC binand 3855,
                                                                 .CC binand 1285)),
                                           ifthenelse(.R1Meas = .Way1EndPosOnRoute,
                                                      .CC binand 43690,
                                                      ifthenelse(.R1Meas = .Way1StartPosOnRoute,
                                                                 .CC binand 61680,
                                                                 .CC binand 41120)))]
consume;

let JunctionsOfOnewaysSameRID2 =
  JunctionRoadPairs feed
    filter [.R1id = .R2id]
    filter [.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId2, WayId]
    projectextend[Jid, R1id, R1Meas, R2id,
                  R2Meas; NewCC: ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                                            ifthenelse(.R2Meas = .Way2EndPosOnRoute,
                                                       .CC binand 21845,
                                                       ifthenelse(.R2Meas = .Way2StartPosOnRoute,
                                                                 .CC binand 3855,
                                                                 .CC binand 1285)),
                                            ifthenelse(.R2Meas = .Way2EndPosOnRoute,
                                                       .CC binand 43690,
                                                       ifthenelse(.R2Meas = .Way2StartPosOnRoute,
                                                                  .CC binand 61680,
                                                                  .CC binand 41120)))]
 consume;

let JunctionsWithOneWayOnRouteA =
  JunctionRoadPairs feed
    filter[.R1id < .R2id]
    filter[.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId1, WayId]
    projectextend[Jid, R1id, R1Meas, R2id,
                  R2Meas; NewCC: ifthenelse(.Way1StartPosOnRoute <= .Way1EndPosOnRoute,
                                            ifthenelse(.R1Meas = .Way1EndPosOnRoute,
                                                       .CC binand 56797,
                                                       ifthenelse(.R1Meas = .Way1StartPosOnRoute,
                                                                  .CC binand 65295,
                                                                  .CC binand 56589)),
                                            ifthenelse(.R1Meas = .Way1EndPosOnRoute,
                                                       .CC binand 61166,
                                                       ifthenelse(.R1Meas = .Way1StartPosOnRoute,
                                                                  .CC binand 65520,
                                                                  .CC binand 61152)))]
consume;

let JunctionsWithOneWayOnRouteB =
  JunctionRoadPairs feed
    filter[.R1id < .R2id]
    filter [.WayId1 # .WayId2]
  OneWayIds feed
  hashjoin[WayId2, WayId]
    projectextend[Jid, R1id, R1Meas, R2id,
                  R2Meas; NewCC: ifthenelse(.Way2StartPosOnRoute <= .Way2EndPosOnRoute,
                                             ifthenelse(.R2Meas = .Way2EndPosOnRoute,
                                                        .CC binand 30583,
                                                        ifthenelse(.R2Meas = .Way2StartPosOnRoute,
                                                                   .CC binand 4095,
                                                                   .CC binand 1911)),
                                             ifthenelse(.R2Meas = .Way2EndPosOnRoute,
                                                        .CC binand 48095,
                                                         ifthenelse(.R2Meas = .Way2StartPosOnRoute,
                                                                    .CC binand 61695,
                                                                    .CC binand 45243)))]
consume;

# Build Relation of Restrictions for way connections

let ViaNodesRel =
  NestedRelationRel feed
    filter [.RelInfo afeed
                    filter [.RefInfo afeed
                                     filter [.RelTagKey contains "restriction"]
                            count > 0]
            count > 0]
    unnest [RelInfo]
      filter[.MemberRole = "via"]
      filter [.MemberType = "node"]
  SpatialPosOfNodes feed
  hashjoin[MemberRef,NodeId]
    projectextend[RelId, NodeId, NodePos; RelTagVal: .RefInfo afeed extract [RelTagValue]]
consume;

let FromWaysRel =
  NestedRelationRel feed
    filter [.RelInfo afeed
                     filter [.RefInfo afeed
                                      filter [.RelTagKey contains "restriction"]
                             count > 0]
            count > 0]
    unnest [RelInfo]
      filter [.MemberRole = "from"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
    project[RelId, WayId, WayCurve]
consume;

let ToWaysRel =
  NestedRelationRel feed
    filter [.RelInfo afeed
                     filter [.RefInfo afeed
                                      filter [.RelTagKey contains "restriction"]
                             count > 0]
            count > 0]
    unnest [RelInfo]
      filter [.MemberRole = "to"]
  SpatialWayCurve feed
  hashjoin[MemberRef, WayId]
    project[RelId, WayId, WayCurve]
consume;

let NodeRestrictions =
  ViaNodesRel feed {v}
  FromWaysRel feed {f}
  hashjoin[RelId_v, RelId_f]
    project [RelId_v, NodeId_v, NodePos_v, RelTagVal_v, WayId_f]
  ToWaysRel feed {t}
  hashjoin[RelId_v, RelId_t]
    project[NodeId_v, NodePos_v, RelTagVal_v, WayId_f, WayId_t]
    sortby [NodeId_v, NodePos_v, WayId_f, WayId_t, RelTagVal_v]
    rdup
consume;

# Compute connectivity codes for known restrictions on single junctions

let RestrictedJunctionsAA1 =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
    filter[.Point = .NodePos_v]
    filter[.WayId1 = .WayId_f]
    filter[.WayId2 = .WayId_t]
    filter [.R1id = .R2id]
    projectextend [Jid, R1id, R1Meas, R2id,
                   R2Meas;NewCC: ifthenelse(.WayId1 = .WayId2,
                                            ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                                                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                                  .CC binand 65519,
                                                                  .CC binand 65533),
                                                       ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                                  .CC binand 65533,
                                                                  .CC binand 65519)),
                                            ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                                                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                                   ifthenelse(.RelTagVal_v contains "no",
                                                                              .CC binand 65503,
                                                                              .CC binand 65327),
                                                                   ifthenelse(.RelTagVal_v contains "no",
                                                                              .CC binand 65534,
                                                                              .CC binand 65521)),
                                                        ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                                   ifthenelse(.RelTagVal_v contains "no",
                                                                              .CC binand 65534,
                                                                              .CC binand 65521),
                                                                   ifthenelse(.RelTagVal_v contains "no",
                                                                              .CC binand 65503,
                                                                              .CC binand 65327))))]
    sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsAA2 =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
    filter[.Point = .NodePos_v]
    filter[.WayId2 = .WayId_f]
    filter[.WayId1 = .WayId_t]
    filter [.R1id = .R2id]
    projectextend [Jid, R1id, R1Meas, R2id,
                   R2Meas;NewCC: ifthenelse(.WayId1 = .WayId2,
                                            ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                                                       ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                  .CC binand 65519,
                                                                  .CC binand 65533),
                                                       ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                  .CC binand 65533,
                                                                  .CC binand 65519)),
                                            ifthenelse(.Way2StartPosOnRoute < .Way2EndPosOnRoute,
                                                       ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                  ifthenelse(.RelTagVal_v contains "no",
                                                                             .CC binand 65503,
                                                                             .CC binand 65327),
                                                                  ifthenelse(.RelTagVal_v contains "no",
                                                                             .CC binand 65534,
                                                                             .CC binand 65521)),
                                            ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                       ifthenelse(.RelTagVal_v contains "no",
                                                                  .CC binand 65534,
                                                                  .CC binand 65521),
                                                       ifthenelse(.RelTagVal_v contains "no",
                                                                  .CC binand 65503,
                                                                  .CC binand 65327))))]
    sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsAB =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
    filter[.Point = .NodePos_v]
    filter[.WayId1 = .WayId_f]
    filter[.WayId2 = .WayId_t]
    filter[.R1id < .R2id]
    projectextend [Jid, R1id, R1Meas, R2id,
                   R2Meas; NewCC: ifthenelse(.WayId1 = .WayId2,
                                        0,
                                        ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                                              ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                                                    ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65471,
                                                                           .CC binand 65359),
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65407,
                                                                           .CC binand 65423)),
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65531,
                                                                           .CC binand 65524),
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65527,
                                                                           .CC binand 65528))),
                                                    ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65407,
                                                                           .CC binand 65423),
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65471,
                                                                           .CC binand 65359)),
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65527,
                                                                           .CC binand 65528),
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65531,
                                                                           .CC binand 65524)))),
                                              ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                                                    ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65531,
                                                                           .CC binand 655524),
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65527,
                                                                           .CC binand 65528)),
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65471,
                                                                           .CC binand 65359),
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65407,
                                                                           .CC binand 65423))),
                                                    ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65527,
                                                                           .CC binand 65528),
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65531,
                                                                           .CC binand 65524)),
                                                          ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                                ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65407,
                                                                           .CC binand 65423),
                                                          ifthenelse(.RelTagVal_v contains "no",
                                                                           .CC binand 65471,
                                                                           .CC binand 65359))))))]
    sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

let RestrictedJunctionsBA =
  JunctionRoadPairs feed
  NodeRestrictions feed
  itSpatialJoin[Point, NodePos_v,4,8]
  filter[.Point = .NodePos_v]
  filter[.WayId2 = .WayId_f]
  filter[.WayId1 = .WayId_t]
  filter[.R1id < .R2id]
  projectextend [Jid, R1id, R1Meas, R2id,
                 R2Meas; NewCC: ifthenelse(.WayId1 = .WayId2,
                                      0,
                                      ifthenelse(.Way1StartPosOnRoute < .Way1EndPosOnRoute,
                                            ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                                                  ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 61439,
                                                                         .CC binand 8191),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                        .CC binand 65279,
                                                                        .CC binand 61951)),
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 57343,
                                                                         .CC binand 12287),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 65023,
                                                                         .CC binand 62207))),
                                                  ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 65279,
                                                                         .CC binand 61951),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 61439,
                                                                         .CC binand 8191)),
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 65023,
                                                                         .CC binand 62207),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 57343,
                                                                         .CC binand 12287)))),
                                            ifthenelse(.Way2StartPosOnRoute < .Way1EndPosOnRoute,
                                                  ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 57343,
                                                                         .CC binand 12287),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 65023,
                                                                         .CC binand 62207)),
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 61439,
                                                                         .CC binand 8191),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 65279,
                                                                         .CC binand 61951))),
                                                  ifthenelse(.Way1StartPosOnRoute = .R1Meas,
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 65023,
                                                                         .CC binand 62207),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                        .CC binand 57343,
                                                                        .CC binand 12287)),
                                                        ifthenelse(.Way2StartPosOnRoute = .R2Meas,
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 65279,
                                                                         .CC binand 61951),
                                                              ifthenelse(.RelTagVal_v contains "no",
                                                                         .CC binand 61439,
                                                                         .CC binand 8191))))))]
    sortby[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
consume;

# compute resulting connectivity code respecting all restrictions computed before
# for each junction. This means a junction may be a oneway and also have
# additional restrictions, such that the connectivity values must be combined.

let Junctions =
  ( ( ( ( JunctionsWithOneWayOnRouteA feed)
        ( JunctionsWithOneWayOnRouteB feed)
        concat)
      ( ( RestrictedJunctionsAA1 feed)
        ( RestrictedJunctionsAA2 feed)
        concat)
      concat)
    ( ( ( RestrictedJunctionsAB feed)
        ( RestrictedJunctionsBA feed)
        concat)
      ( ( JunctionsOfOnewaysSameRID1 feed)
        ( JunctionsOfOnewaysSameRID2 feed)
        concat)
      concat)
    concat)
  ( ( ( RoadEndPoints feed)
      ( JunctionsAtRoadEndPairs feed)
      concat)
    ( ( JunctionRoadPairs feed projectextend[Jid, R1id, R1Meas, R2id, R2Meas; NewCC: .CC])
      ( JunctionsOfCycles feed)
      concat)
    concat)
  concat
    project[Jid, R1id, R1Meas, R2id, R2Meas, NewCC]
    sortby[Jid, R1id, R1Meas, R2id, R2Meas]
    groupby[Jid, R1id, R1Meas, R2id, R2Meas; CC: group feed
                                                       projecttransformstream[NewCC]
                                                       binands]
consume;

# Build network with all possible restrictions

let KENetwork =
  thenetwork(1,
             0.0001,
             Roads feed
                projectextend[Rid, CurvLength,
                                   Curve; Dual: FALSE,
                                   StartS: get_startsmaller(.Curve)]
             consume,
             Junctions feed
                project [R1id, R1Meas, R2id, R2Meas, CC]
             consume);

# Script finished close database

close database;
